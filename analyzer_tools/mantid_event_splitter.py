#!/usr/bin/env python3
"""
Mantid Event Splitter Script Generator

Generate a Python script that uses Mantid to split neutron event data
based on EIS timing intervals.

This tool creates a standalone Python script that can be executed in a 
Mantid environment to filter neutron scattering events by time intervals
derived from EIS measurements.

The generated script uses the FilterEvents algorithm with absolute time
filtering to split the event workspace into multiple output workspaces,
one for each EIS measurement interval.
"""

import argparse
import csv
import os
from datetime import datetime
from pathlib import Path
from typing import List, Tuple, Optional


def load_timing_data(filepath: str) -> List[dict]:
    """
    Load timing data from a CSV file generated by eis_timing_extractor.
    
    Args:
        filepath: Path to the timing CSV file
        
    Returns:
        List of dictionaries with timing information
    """
    data = []
    with open(filepath, 'r') as f:
        reader = csv.DictReader(f)
        for row in reader:
            data.append(row)
    return data


def parse_iso_datetime(iso_string: str) -> datetime:
    """
    Parse an ISO 8601 datetime string.
    
    Args:
        iso_string: ISO 8601 formatted datetime string
        
    Returns:
        datetime object
    """
    # Handle various ISO formats
    formats = [
        '%Y-%m-%dT%H:%M:%S.%f',
        '%Y-%m-%dT%H:%M:%S',
        '%Y-%m-%d %H:%M:%S.%f',
        '%Y-%m-%d %H:%M:%S'
    ]
    
    for fmt in formats:
        try:
            return datetime.strptime(iso_string, fmt)
        except ValueError:
            continue
    
    raise ValueError(f"Could not parse datetime: {iso_string}")


def get_timing_intervals(data: List[dict]) -> List[Tuple[str, str, int]]:
    """
    Extract timing intervals from EIS data.
    
    Creates intervals where each interval spans from one EIS measurement
    to the next.
    
    Args:
        data: List of dictionaries with wall_clock_time field
        
    Returns:
        List of (start_time, end_time, index) tuples
    """
    if len(data) < 2:
        return []
    
    intervals = []
    for i in range(len(data) - 1):
        start_time = data[i]['wall_clock_time']
        end_time = data[i + 1]['wall_clock_time']
        intervals.append((start_time, end_time, i))
    
    return intervals


def generate_mantid_script(intervals: List[Tuple[str, str, int]],
                           event_file: str,
                           output_dir: str,
                           workspace_prefix: str = 'eis_interval') -> str:
    """
    Generate a Mantid Python script for event filtering.
    
    Args:
        intervals: List of (start_time, end_time, index) tuples
        event_file: Path to the HDF5 event data file
        output_dir: Directory for output workspaces
        workspace_prefix: Prefix for output workspace names
        
    Returns:
        Python script as a string
    """
    
    # Build the time intervals as Python code
    interval_rows = []
    for start_time, end_time, idx in intervals:
        interval_rows.append(f"    ('{start_time}', '{end_time}', '{idx}')")
    
    intervals_code = ',\n'.join(interval_rows)
    
    script = f'''#!/usr/bin/env python3
"""
Mantid Event Filtering Script

This script was auto-generated by mantid_event_splitter.py
It filters neutron scattering events based on EIS measurement timing intervals.

To run this script, execute it in a Mantid Python environment:
    python {workspace_prefix}_filter_script.py

Or run it within MantidWorkbench.
"""

from datetime import datetime, timedelta
from numpy import datetime64, timedelta64

# Import Mantid algorithms
from mantid.simpleapi import (
    Load, 
    FilterEvents, 
    CreateEmptyTableWorkspace,
    SaveNexus,
    mtd
)


def create_table_workspace(table_ws_name, column_def_list):
    """
    Create an empty table workspace with specified columns.
    
    Args:
        table_ws_name: Name for the table workspace
        column_def_list: List of (data_type, column_name) tuples
        
    Returns:
        Table workspace object
    """
    CreateEmptyTableWorkspace(OutputWorkspace=table_ws_name)
    table_ws = mtd[table_ws_name]
    for col_tup in column_def_list:
        data_type = col_tup[0]
        col_name = col_tup[1]
        table_ws.addColumn(data_type, col_name)
    return table_ws


def parse_iso_datetime(iso_string):
    """Parse ISO datetime string to datetime object."""
    formats = [
        '%Y-%m-%dT%H:%M:%S.%f',
        '%Y-%m-%dT%H:%M:%S',
    ]
    for fmt in formats:
        try:
            return datetime.strptime(iso_string, fmt)
        except ValueError:
            continue
    raise ValueError(f"Could not parse datetime: {{iso_string}}")


def convert_to_absolute_seconds(dt):
    """
    Convert datetime to seconds relative to GPS epoch (1990-01-01).
    
    This is the format expected by Mantid's FilterEvents algorithm
    when using absolute time filtering.
    """
    gps_epoch = datetime64('1990-01-01T00:00:00')
    dt64 = datetime64(dt.isoformat())
    delta = dt64 - gps_epoch
    return float(delta / timedelta64(1, 's'))


def main():
    # Configuration
    event_file = r'{event_file}'
    output_dir = r'{output_dir}'
    workspace_prefix = '{workspace_prefix}'
    
    # EIS timing intervals (start_time, end_time, target_index)
    # Generated from EIS timing data
    timing_intervals = [
{intervals_code}
    ]
    
    print(f"Loading event data from: {{event_file}}")
    
    # Load the event workspace
    # Adjust the loader algorithm based on your file format
    # For NeXus files, use Load or LoadEventNexus
    ws = Load(Filename=event_file, OutputWorkspace='events_raw')
    
    print(f"Loaded workspace with {{ws.getNumberEvents()}} events")
    print(f"Run start: {{ws.run().startTime()}}")
    print(f"Run end: {{ws.run().endTime()}}")
    
    # Convert timing intervals to absolute seconds
    abs_times = []
    for start_iso, end_iso, target in timing_intervals:
        start_dt = parse_iso_datetime(start_iso)
        end_dt = parse_iso_datetime(end_iso)
        start_sec = convert_to_absolute_seconds(start_dt)
        end_sec = convert_to_absolute_seconds(end_dt)
        abs_times.append((start_sec, end_sec, target))
    
    print(f"\\nCreating filter with {{len(abs_times)}} time intervals")
    
    # Create the filter table workspace
    filter_ws = create_table_workspace(
        'eis_time_filter',
        [('float', 'start'), ('float', 'stop'), ('str', 'target')]
    )
    
    for start_sec, end_sec, target in abs_times:
        filter_ws.addRow((start_sec, end_sec, str(target)))
    
    print("Applying event filter...")
    
    # Apply the filter
    # RelativeTime=False means we're using absolute times
    FilterEvents(
        InputWorkspace='events_raw',
        SplitterWorkspace='eis_time_filter',
        GroupWorkspaces=True,
        OutputWorkspaceBaseName=workspace_prefix,
        RelativeTime=False
    )
    
    print(f"\\nFiltering complete. Output workspaces created with prefix: {{workspace_prefix}}")
    
    # Save each filtered workspace
    import os
    os.makedirs(output_dir, exist_ok=True)
    
    for start_iso, end_iso, target in timing_intervals:
        ws_name = f"{{workspace_prefix}}_{{target}}"
        if ws_name in mtd:
            output_file = os.path.join(output_dir, f"{{ws_name}}.nxs")
            print(f"Saving {{ws_name}} to {{output_file}}")
            SaveNexus(InputWorkspace=ws_name, Filename=output_file)
    
    print("\\nDone!")


if __name__ == '__main__':
    main()
'''
    
    return script


def generate_relative_time_script(intervals: List[Tuple[str, str, int]],
                                   event_file: str,
                                   output_dir: str,
                                   run_start_time: str,
                                   workspace_prefix: str = 'eis_interval') -> str:
    """
    Generate a Mantid script using relative time filtering.
    
    This is an alternative approach that uses times relative to the run start.
    
    Args:
        intervals: List of (start_time, end_time, index) tuples
        event_file: Path to the HDF5 event data file
        output_dir: Directory for output workspaces
        run_start_time: ISO format string of the run start time
        workspace_prefix: Prefix for output workspace names
        
    Returns:
        Python script as a string
    """
    
    # Convert absolute times to relative times
    run_start = parse_iso_datetime(run_start_time)
    
    relative_intervals = []
    for start_time, end_time, idx in intervals:
        start_dt = parse_iso_datetime(start_time)
        end_dt = parse_iso_datetime(end_time)
        
        start_rel = (start_dt - run_start).total_seconds()
        end_rel = (end_dt - run_start).total_seconds()
        
        relative_intervals.append((start_rel, end_rel, idx))
    
    # Build the interval rows
    interval_rows = []
    for start_rel, end_rel, idx in relative_intervals:
        interval_rows.append(f"    ({start_rel:.6f}, {end_rel:.6f}, '{idx}')")
    
    intervals_code = ',\n'.join(interval_rows)
    
    script = f'''#!/usr/bin/env python3
"""
Mantid Event Filtering Script (Relative Time)

This script was auto-generated by mantid_event_splitter.py
It filters neutron scattering events based on EIS measurement timing intervals
using time relative to the run start.

Run start time: {run_start_time}

To run this script, execute it in a Mantid Python environment.
"""

from mantid.simpleapi import (
    Load, 
    FilterEvents, 
    CreateEmptyTableWorkspace,
    SaveNexus,
    mtd
)
import os


def create_table_workspace(table_ws_name, column_def_list):
    """Create an empty table workspace with specified columns."""
    CreateEmptyTableWorkspace(OutputWorkspace=table_ws_name)
    table_ws = mtd[table_ws_name]
    for col_tup in column_def_list:
        data_type = col_tup[0]
        col_name = col_tup[1]
        table_ws.addColumn(data_type, col_name)
    return table_ws


def main():
    # Configuration
    event_file = r'{event_file}'
    output_dir = r'{output_dir}'
    workspace_prefix = '{workspace_prefix}'
    
    # EIS timing intervals in seconds relative to run start
    # (start_seconds, end_seconds, target_index)
    timing_intervals = [
{intervals_code}
    ]
    
    print(f"Loading event data from: {{event_file}}")
    
    # Load the event workspace
    ws = Load(Filename=event_file, OutputWorkspace='events_raw')
    
    print(f"Loaded workspace with {{ws.getNumberEvents()}} events")
    
    # Create the filter table workspace
    filter_ws = create_table_workspace(
        'eis_time_filter',
        [('float', 'start'), ('float', 'stop'), ('str', 'target')]
    )
    
    for start_sec, end_sec, target in timing_intervals:
        filter_ws.addRow((start_sec, end_sec, str(target)))
    
    print(f"Applying filter with {{len(timing_intervals)}} time intervals")
    
    # Apply the filter with relative time
    FilterEvents(
        InputWorkspace='events_raw',
        SplitterWorkspace='eis_time_filter',
        GroupWorkspaces=True,
        OutputWorkspaceBaseName=workspace_prefix,
        RelativeTime=True
    )
    
    print(f"Filtering complete.")
    
    # Save each filtered workspace
    os.makedirs(output_dir, exist_ok=True)
    
    for start_sec, end_sec, target in timing_intervals:
        ws_name = f"{{workspace_prefix}}_{{target}}"
        if ws_name in mtd:
            output_file = os.path.join(output_dir, f"{{ws_name}}.nxs")
            print(f"Saving {{ws_name}} to {{output_file}}")
            SaveNexus(InputWorkspace=ws_name, Filename=output_file)
    
    print("Done!")


if __name__ == '__main__':
    main()
'''
    
    return script


def main():
    """Main CLI entry point."""
    parser = argparse.ArgumentParser(
        description='Generate Mantid script for event filtering based on EIS timing',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Generate script from timing CSV
  python mantid_event_splitter.py --timing-file timing.csv --event-file events.h5 --output-script filter.py
  
  # Generate script with custom workspace prefix
  python mantid_event_splitter.py -t timing.csv -e events.h5 -o filter.py --prefix my_experiment
  
  # Use relative time filtering
  python mantid_event_splitter.py -t timing.csv -e events.h5 -o filter.py --relative --run-start "2025-04-20T10:55:16"
"""
    )
    
    parser.add_argument('--timing-file', '-t', type=str, required=True,
                        help='Path to timing CSV file from eis_timing_extractor')
    parser.add_argument('--event-file', '-e', type=str, required=True,
                        help='Path to HDF5/NeXus event data file')
    parser.add_argument('--output-script', '-o', type=str, required=True,
                        help='Path for output Python script')
    parser.add_argument('--output-dir', '-d', type=str, default='./filtered_events',
                        help='Directory for filtered output files (default: ./filtered_events)')
    parser.add_argument('--prefix', '-p', type=str, default='eis_interval',
                        help='Prefix for output workspace names (default: eis_interval)')
    parser.add_argument('--relative', '-r', action='store_true',
                        help='Use relative time filtering instead of absolute')
    parser.add_argument('--run-start', type=str,
                        help='Run start time (ISO format) for relative time filtering')
    
    args = parser.parse_args()
    
    # Load timing data
    print(f"Loading timing data from: {args.timing_file}")
    data = load_timing_data(args.timing_file)
    print(f"  Found {len(data)} timing points")
    
    # Get timing intervals
    intervals = get_timing_intervals(data)
    print(f"  Created {len(intervals)} time intervals")
    
    if not intervals:
        print("Error: Not enough data points to create intervals")
        return 1
    
    # Generate script
    if args.relative:
        if not args.run_start:
            # Use first timing point as run start
            args.run_start = data[0]['wall_clock_time']
            print(f"  Using first data point as run start: {args.run_start}")
        
        script = generate_relative_time_script(
            intervals,
            args.event_file,
            args.output_dir,
            args.run_start,
            args.prefix
        )
    else:
        script = generate_mantid_script(
            intervals,
            args.event_file,
            args.output_dir,
            args.prefix
        )
    
    # Write script
    with open(args.output_script, 'w') as f:
        f.write(script)
    
    print(f"\nGenerated Mantid script: {args.output_script}")
    print(f"  Event file: {args.event_file}")
    print(f"  Output directory: {args.output_dir}")
    print(f"  Workspace prefix: {args.prefix}")
    print(f"  Time intervals: {len(intervals)}")
    print(f"\nTo run the script, execute it in a Mantid Python environment.")
    
    return 0


if __name__ == '__main__':
    exit(main())
